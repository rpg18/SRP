# The following initializes usage of Bioc devel
#BiocManager::install(version='devel')
library(SingleCellExperiment) # development version 1.7.0 
library(SC3) # version 1.13.0 
library(scater) # version 1.13.9 
#library(stats4) # version 3.6.1
#### Input (select MMquant matrix or Darmanis et al, 2015 matrix) ----

# Darmenis matrix:
# Raw reads counting matrix:
#trial<- read.csv(("/home/rpg18/Desktop/SRP_article/PIPELINE/Pipeline_SecondSteps/Sc3/output_sorted.tsv"), sep='\t')
# Extra article's information:
#pipe<- read.csv(("/home/rpg18/Desktop/SRP_article/PIPELINE/Pipeline_SecondSteps/pipe2.tsv"), sep='\t')

# Darmanis Matrix preparation for sce object creation
#trial<- trial[1:22085,] # remove last 3 rows of the matrix
#trial_genes <- trial$Gene_name
#rownames(trial) <- trial_genes
#trial <- subset(trial, select = -Gene_name)
#dim(trial)

# MMquant matrix:
# Raw reads counting matrix: 
trial<- read.csv(("/home/rpg18/Desktop/SRP_article/PIPELINE/Pipeline_SecondSteps/Merged_out_mmquant.csv"), sep='\t')
# Extra article's information:
pipe<- read.csv(("/home/rpg18/Desktop/SRP_article/PIPELINE/Pipeline_SecondSteps/pipe2_SRR.tsv"), sep='\t') # age and cell-type information (no SRR1974800)


# MMquant Matrix preparation for sce object creation
trial_genes <- trial$Gene
rownames(trial) <- trial_genes
trial <- subset(trial, select = -Gene)
dim(trial)
dim(pipe)

### sce_Object ----
# Matrix:
cts <- as.matrix(trial)

# sce Object creation:
sce<- SingleCellExperiment(
  assays = list(
    counts = cts),
  colData = pipe
)
# sce object
dim(sce)
# raw counting matrix
dim(cts)

## mito_Genes ----
# mito_Genes identification:
mito.genes <- grep(pattern = "^MT-", x = rownames(cts), value = TRUE)
length(mito.genes) # number of mitochondrial genes
# Percentage mito_Genes
percent.mito <- Matrix::colSums(cts[mito.genes, ])/Matrix::colSums(cts)
sce$percent.mito <- percent.mito
#sce

# writes all its results obtained for cells to the colData slot of the sce object, adding additional columns
col_data <- colData(sce)
head(col_data[ , grep("sc3_", colnames(col_data))])

### QC_metrics ----
# Scater-QC:
sce <- calculateQCMetrics(sce, 
                          feature_controls = list(mito = 500:1000),
                          cell_controls = list(empty = 1:5, damaged = 31:40))
                          #, compact = TRUE)

# writes all its results obtained for cells to the colData slot of the sce object, adding additional columns
col_data <- colData(sce)
head(col_data[ , grep("sc3_", colnames(col_data))])
sce$total_counts
# Store scater output:
qc<- sce$scater_qc

# Check sce object:
colnames(colData(sce))                         
colnames(rowData(sce))

### Normalisation ----
# Normalisation by library size: 
sizeFactors(sce) <- librarySizeFactors(sce)
summary(sizeFactors(sce))
# Scater-default:
#library(scater)
sce <- normalize(sce, exprs_values = "counts", return_log = TRUE,
                      log_exprs_offset = NULL, centre_size_factors = TRUE,
                      preserve_zeroes = FALSE)
# Scater-CPM:
cpm(sce) <- calculateCPM(sce)

# Store log normalisation:
log<- logcounts(sce)

# Check normalisation:
assayNames(sce)
identical(exprs(sce), logcounts(sce))
counts(sce)[,1]

## Filtering(optional) ----
# Filter merged_genes generated by mmquant:
merged_genes<- grep(pattern = "--", x = rownames(cts), value = TRUE) # cts is the raw matrix
length(merged_genes)
#filtered <-sce[!row.names(sce)%in%merged_genes,] # filters merged-genes
#rownames(filtered)

# Check filtering
dim(sce) # raw matrix
#dim(filtered) # filtered

## Top_50_before_Filt ----
plotHighestExprs(sce, exprs_values = "counts")

## Top_50_after_Filt ----
plotHighestExprs(filtered, exprs_values = "counts")

### SC3-clustering(see-Supplementary_code) ----
# Define feature names in feature_symbol column:
filtered<- sce # we are not filtering
rowData(filtered)$feature_symbol <- rownames(filtered)

# Remove features with duplicated names:
filtered <- filtered[!duplicated(rowData(filtered)$feature_symbol), ]

# Clustering estimation:
filtered <- sc3_estimate_k(filtered) 
str(metadata(filtered)$sc3) # k = 13 estimated for mmquant -> unfiltered and filtered gave the same number of clusters

# Clustering:
filtered <- sc3(filtered, ks = 2:15, biology= TRUE, n_cores = 4) # biology = TRUE allows outliers and marker_genes identification (cell and gene filters)
dim(filtered)

# Define feature names in feature_symbol column
rowData(filtered)$feature_symbol <- rownames(filtered)
# Remove features with duplicated names
filtered <- filtered[!duplicated(rowData(filtered)$feature_symbol), ]

## SC3-solution ----
# Quantitative measure of the diagonality of the consensus matrix:
sc3_plot_silhouette(filtered, k = 9)
sc3_plot_silhouette(filtered, k = 13)

# Cluster stability:
sc3_plot_cluster_stability(filtered, k = 9)
sc3_plot_cluster_stability(filtered, k = 13)

# Cluster consensus:
sc3_plot_consensus(filtered, k = 9)
sc3_plot_consensus(filtered, k = 13)

# PCA_plots:
plotPCA(filtered, colour_by = "age")
plotPCA(filtered, colour_by = "sc3_2_clusters")
plotPCA(filtered, colour_by = "sc3_8_clusters")
plotPCA(filtered, colour_by = "cell_type")
plotPCA(filtered, colour_by = "sc3_3_clusters")
plotPCA(filtered, colour_by = "sc3_9_clusters")
plotPCA(filtered, colour_by = "sc3_13_clusters")

plotPCA(filtered, colour_by = "sc3_14_clusters")

## Graphs-SC3_functions ----
# PCA_outliers:
plotPCAtest <- plotPCA(
  filtered, 
  colour_by = "sc3_13_clusters", 
  size_by = "sc3_13_log2_outlier_score"
)

plotPCAtest <- plotPCA(
  filtered, 
  colour_by = "sc3_9_clusters", 
  size_by = "sc3_9_log2_outlier_score"
)

# Plot_functions:
# 9 clusters
sc3_plot_consensus(filtered, k = 9)

# 13 clusters
sc3_plot_consensus(filtered, k = 13)

sc3_plot_consensus(
  filtered, k = 9, 
  show_pdata = c(
    "cell_type", 
    "log10_total_features_by_counts",
    "sc3_9_clusters", 
    "sc3_9_log2_outlier_score"
  )
)

# Expression matrix after cell and gene filters:
sc3_plot_expression(filtered, k = 15)



# DE_genes:
sc3_plot_de_genes(filtered, k = 9)


# Marker_genes:
sc3_plot_markers(filtered, k = 9)

sc3_plot_markers(
  filtered, k = 9, 
  show_pdata = c(
    "cell_type", 
    "log10_total_features",
    "sc3_9_clusters", 
    "sc3_9_log2_outlier_score"
  )
)

sc3_plot_markers(
  filtered, k = 2, 
  show_pdata = c(
    "age", 
    "log10_total_features",
    "sc3_2_clusters", 
    "sc3_2_log2_outlier_score"
  )
)


## Visualitation_Exprs ----
# Frequence of expression as a function of the mean:
plotExprsFreqVsMean(sce) # before filtering
plotExprsFreqVsMean(filtered) # after filtering

## Export_results ----
# writes all its results obtained for cells to the colData slot of the sce object, adding additional columns
col_data <- colData(filtered)
head(col_data[ , grep("sc3_", colnames(col_data))])

# Export results:
sc3_export_results_xls(filtered)

#setwd("")
output_filtered <- colData(filtered)
colData(filtered)
write.table(output_filtered, file="info_mmquant_unFILTERED.csv", sep='\t', col.names = NA)

## Graphs-TSNE ----
# TSNE_ncomponents:
plotTSNE(filtered, ncomponents = 3, colour_by = "age")
plotTSNE(filtered, ncomponents = 3, colour_by = "cell_type")
plotTSNE(filtered, ncomponents = 3, colour_by = "sc3_2_clusters")
plotTSNE(filtered, ncomponents = 3, colour_by = "sc3_3_clusters")
plotTSNE(filtered, ncomponents = 3, colour_by = "sc3_9_clusters")
plotTSNE(filtered, ncomponents = 3, colour_by = "sc3_10_clusters")
plotTSNE(filtered, ncomponents = 3, colour_by = "sc3_13_clusters")

## More_graphs-Scater ----
# Scater_plotting:
plotScater(filtered, block1 = "sc3_9_clusters", block2 = "cell_type",
           colour_by = "sc3_9_clusters", nfeatures = 200, exprs_values = "counts") # comparing with article's data


### Specific_gene_analysis:

## ----plot-difmap-1comp-colby-sizeby-exprs----------------------------------
#BiocManager::install("destiny", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.6")
library(destiny) # version 2.15.0
example_sce <- runDiffusionMap(filtered)
plotDiffusionMap(example_sce, colour_by = "cell_type", size_by = "SYS1-DBNDD2--DBNDD2")


### Supplementary_code(SC3) ----
## Clustering-preparation:
# Define feature names in feature_symbol column:
rowData(filtered)$feature_symbol <- rownames(filtered)
# Remove features with duplicated names:
filtered <- filtered[!duplicated(rowData(filtered)$feature_symbol), ]

# Preparation:
filtered <- sc3_prepare(filtered)
str(metadata(filtered)$sc3)
rowData(filtered)$sc3_gene_filter
length(rowData(filtered)$sc3_gene_filter) # Check gene_filter: FALSE or TRUE genes
dim(filtered)

## Clustering-estimation: 
filtered <- sc3_estimate_k(filtered) 
str(metadata(filtered)$sc3) # k=13 estimated for mmquant -> filtered

## Distance-calculation between the cells (distance matrices):
filtered <- sc3_calc_dists(filtered)
names(metadata(filtered)$sc3$distances)

## Transformation-calculation of the distance matrices:
filtered <- sc3_calc_transfs(filtered)
names(metadata(filtered)$sc3$transformations)
metadata(filtered)$sc3$distances
sc3_interactive(filtered)

## Clustering-step:
filtered <- sc3_kmeans(filtered, ks = 2:15) # num_cells 2,000, k = 50
names(metadata(filtered)$sc3$kmeans)

## Consensus-calculation for each value of k:
col_data <- colData(filtered)
head(col_data[ , grep("sc3_", colnames(col_data))])

filtered <- sc3_calc_consens(filtered)
names(metadata(filtered)$sc3$consensus)
names(metadata(filtered)$sc3$consensus$`14`)
metadata(filtered)$sc3$kmeans

col_data <- colData(filtered)
head(col_data[ , grep("sc3_", colnames(col_data))])

## Biology-calculation:
filtered <- sc3_calc_biology(filtered, ks = 2:14)

## Cell-outliers:
col_data <- colData(filtered)
head(col_data[ , grep("sc3_", colnames(col_data))])
#?get_outl_cells

## DE and marker_genes:
row_data <- rowData(filtered)
head(row_data[ , grep("sc3_", colnames(row_data))])
#?get_de_genes
#?get_marker_genes

## Clustering-solution:
col_data <- colData(filtered)
colData(filtered)
col_data$sc3_14_clusters
head(col_data[ , grep("sc3_", colnames(col_data))])

### Ttop25 ----
info <- read.csv("/home/rpg18/Desktop/SRP_article/PIPELINE/Pipeline_SecondSteps/Sc3/Results_attempts_trial/Authors/NEW/new.R/Norm_postfilter/info_mmquant_unFILTERED.csv", sep='\t')

sample <- info$Run
rownames(info) <- sample

info <- subset(info, select = -Run)
cluster<- info$sc3_9_clusters

lista<- cbind(sample,cluster)

lista<- DataFrame(lista)
lista$sample
rownames(lista)<- sample
lista<- subset(lista, -sample)
lista
cluster1 <-c()
cluster2 <-c()
cluster3 <-c()
cluster4 <-c()
cluster5 <-c()
cluster6 <-c()
cluster7 <-c()
cluster8 <-c()
cluster9 <-c()

info$sc3_9_clusters[count]

count = 1

for(k in row.names(lista)){
  meh <- info$sc3_9_clusters[count]
  count <- count + 1
  if (meh %in% 1){cluster1<-append(cluster1,k)}
  else if (meh %in% 2){cluster2<-append(cluster2,k)}
  else if (meh %in% 3){cluster3<-append(cluster3,k)}
  else if (meh %in% 4){cluster4<-append(cluster4,k)}
  else if (meh %in% 5){cluster5<-append(cluster5,k)}
  else if (meh %in% 6){cluster6<-append(cluster6,k)}
  else if (meh %in% 7){cluster7<-append(cluster7,k)}
  else if (meh %in% 8){cluster8<-append(cluster8,k)}
  else if (meh %in% 9){cluster9<-append(cluster9,k)}
  
}

write.table(cluster1, file = "cells_cluster1.txt", col.names = NA)
write.table(cluster2, file = "cells_cluster2.txt", col.names = NA)
write.table(cluster3, file = "cells_cluster3.txt", col.names = NA)

write.table(cluster4, file = "cells_cluster4.txt", col.names = NA)
write.table(cluster5, file = "cells_cluster5.txt", col.names = NA)
write.table(cluster6, file = "cells_cluster6.txt", col.names = NA)
write.table(cluster7, file = "cells_cluster7.txt", col.names = NA)
write.table(cluster8, file = "cells_cluster8.txt", col.names = NA)
write.table(cluster9, file = "cells_cluster9.txt", col.names = NA)


